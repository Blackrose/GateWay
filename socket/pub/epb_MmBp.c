//  epb_MmBp.c
//  Embedded Proto Buffer
//
//  Generated by harlliu@tencent.com on 14-11-26.
//  Copyright 2014 Tencent. All rights reserved.
//
//  Version : 1.0.4

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "epb_MmBp.h"
//====================================================

#define 		TAG_BaseResponse_ErrCode										0x08
#define 		TAG_BaseResponse_ErrMsg											0x12
#define 		TAG_BaseRequest_Code												0x08


//===================== public BaseRequest function ===============================

int epb_base_request_pack_size(BaseRequest *request)
{
	int pack_size = 0;
    if ( request == NULL )
        printf("\r\n");
	return pack_size;
}

int epb_pack_base_request(BaseRequest *request, uint8_t *buf, int buf_len)
{
	Epb epb;
    if ( request == NULL )
        printf("\r\n");

	epb_pack_init(&epb, buf, buf_len);
	return epb_get_packed_size(&epb);
}


BaseRequest *epb_unpack_base_request(BaseRequest *base_request,const uint8_t *buf, int buf_len)
{
	Epb epb;
//	const char	*str;
	epb_unpack_init(&epb, buf, buf_len);
	if (base_request ==NULL )
		return base_request;
	if (!epb_has_tag(&epb, TAG_BaseRequest_Code)) {
		base_request->none = NULL;
	}
	return base_request;
}

//============= include response struct pack ==============================
int epb_base_response_pack_size(BaseResponse *response)
{
	int pack_size = 0;
	if (response == NULL){
		return pack_size;
	}
	pack_size += epb_varint32_pack_size(TAG_BaseResponse_ErrCode, response->err_code, false);		
	if (response->has_err_msg ){
		pack_size += epb_length_delimited_pack_size(TAG_BaseResponse_ErrMsg, response->err_msg.len);
	}
	return pack_size;
}

int epb_pack_base_response(BaseResponse *response, uint8_t *buf, int buf_len)
{
	Epb epb;
	int ret;
	epb_pack_init(&epb, buf, buf_len);
	if (response == NULL){
		return epb_get_packed_size(&epb);
	}
	ret = epb_set_int32(&epb, TAG_BaseResponse_ErrCode, response->err_code);
	if (ret < 0) return ret;
	if (response->has_err_msg) {
		ret = epb_set_string(&epb, TAG_BaseResponse_ErrMsg, response->err_msg.str, response->err_msg.len);
		if (ret < 0) return ret;
	}
	return epb_get_packed_size(&epb);
}

//*************************************************************
BaseResponse *epb_unpack_base_response(BaseResponse *base_response,const uint8_t *buf, int buf_len)
{
	Epb epb;
	const char	*str;
	epb_unpack_init(&epb, buf, buf_len);
	if (base_response ==NULL )
		return base_response;
	if (!epb_has_tag(&epb, TAG_BaseResponse_ErrCode)) {
		base_response->has_err_msg = false;
		base_response->err_code = 0;
		base_response->err_msg.len = 0;
		base_response->err_msg.str = NULL;
		return base_response;
	}

//	memset(base_response, 0, sizeof(BaseResponse));
	base_response->err_code = epb_get_int32(&epb, TAG_BaseResponse_ErrCode);
	if (epb_has_tag(&epb, TAG_BaseResponse_ErrMsg)) {
		str = epb_get_string(&epb, TAG_BaseResponse_ErrMsg, &base_response->err_msg.len);
		memcpy((void *)base_response->err_msg.str,str,base_response->err_msg.len);
		base_response->has_err_msg = true;
	}
	return base_response;
}

void epb_unpack_base_response_free(BaseResponse *response)
{
	free(response);
}



